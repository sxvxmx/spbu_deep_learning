# Задание 2. Свертки и базовые слои 
Это задание будет являться духовным наследником первого. 
Вы уже научились делать шаги градиентного спуска и вспомнили, как устроен базовый линейный слой.
На этой неделе мы построим прототип базового фреймворка до конца (собственно, многое вы сможете скопировать, если захотите). 
Хоть вы уже и знаете о torch.nn, для выполнения задания его использовать нельзя. 
Однако все элементы, которые вы будете реализовывать, достаточно просты.

## Задача 1. (2 балла)
Реализуйте слой BatchNorm (nn.BatchNorm). 
## Задача 2. (2 балла)
Реализуйте слой Linear (nn.Linear). 
## Задача 3. (2 балла)
Реализуйте слой Dropout(nn.Dropout)
## Задача 4. {*} (2 балла, 1 за каждый следующий за слой)
Реализуйте одно или более из:
  - слой ReLU(nn.ReLU)
  - слой Sigmoid(nn.Sigmoid)
  - слой Softmax(nn.Softmax)

## Задача 5. {*}. 
Вы получите по 1 дополнительному баллу за слой, 
если реализуете в рамках фреймворка из задания 3 прошлой работы

# Задание 2. {*} 3 балла
Реализуйте медианный фильтр. 
Для текущего пикселя, пиксели, которые «попадают» в матрицу, 
сортируются, и выбирается медианное значение из отсортированного массива. 
Это значение и является выходным для текущего пикселя.
Используйте только чистый torch. Покажите результат на примере для размера ядра 3, 5, 10

# Задание 3. 6 баллов
Реализуйте следующие классы (указана сигнатура __init__):
- BaseTransform(p: float) [*базовый класс для всех трансформаций*]
- RandomCrop(p: float, **kwargs)
- RandomRotate(p: float, **kwargs)
- RandomZoom(p: float, **kwargs) {*}
- ToTensor() 
- Compose(list[BaseTransform])

Последний класс должен принимать на вход список инстансов трех других.
При вызове метода __call__ он должен последовательно вызывать трансформации из списка.
При вызове каждого из них с вероятностью p должно 
применяться изменение изображения, с вероятностью 1-p должно возвращаться исходное 
изображение. Класс входного изображения у всех классов - PIL.Image, выходного тоже.
Класс ToTensor должен принимать на вход PIL.Image, возвращать - torch.Tensor.

**torch.nn использовать нельзя!**

{*} (1 балл) Протестируйте ваши классы на воспроизводимость, результат, граничные случаи.

# Задание 4. 3 балла
Примените трансформации из задания 3 в качестве трансформаций датасета из практики 2.2.
**В этом задании можно пользоваться torch.nn, за исключением трансформаций.**
Покажите, как меняются лосс и метрики на трейне и на тесте в зависимости от количества и вероятностей трансформаций.
Проведите обучение на большом количестве эпох. 
Опишите, что вы наблюдаете для каждого случая и какая есть разница,
если применить трансформации.
Предоставьте графики в matplotlib или tensorboard (+1 балл) в 
ноутбуке (в случае с tensorboard можно в отдельном окне) с наглядными примерами

# Задание 5. {*}  4 балла
Настройте проект в weights and biases, настройте логгинг туда из вашего цикла обучения (задание 4).
Выводите лосс и метрики на трейне и на тесте. Графики из задания 4 в таком случае можно выводить только туда.
Можете сохранять параметры обучения в качестве констант, и смотреть на сводную таблицу.
